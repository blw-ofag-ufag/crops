PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX : <https://agriculture.ld.admin.ch/crops/>
PREFIX ct: <https://agriculture.ld.admin.ch/crops/cultivationtype/>
PREFIX schema: <http://schema.org/>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>

SELECT DISTINCT ?S ?relation ?T
WHERE {
  
  # BLOCK 1: ORIGINAL QUERY (Source + Matches)
  {
      BIND("__SOURCE__" AS ?DB_S)
      BIND("__TARGET__" AS ?DB_T)

      # 2. ANCHOR: FIND SOURCE CONCEPTS
      ?S a :CultivationType ;
         :partOf+ ct:14 ;
         :hasMembership [ schema:name ?DB_S ] .

      # 3. FIND TARGETS & DETERMINE RELATION
      OPTIONAL
      {
        {
          # CASE A: IDENTITY
          ?S :hasMembership [ schema:name ?DB_T ] .
          BIND(skos:exactMatch AS ?relation)
          BIND(?S AS ?T)
        }
        UNION
        {
          # CASE B: SUBSUMPTION
          FILTER NOT EXISTS { ?S :hasMembership / schema:name ?DB_T }
          ?S :partOf+ ?T .
          ?T :hasMembership [ schema:name ?DB_T ] .
          BIND(skos:broadMatch AS ?relation)
        }
        UNION
        {
          # CASE C: SUPER-ORDINATION
          FILTER NOT EXISTS { ?S :hasMembership/schema:name ?DB_T }
          ?T :partOf+ ?S ;
             :hasMembership [ schema:name ?DB_T ] .
          BIND(skos:narrowMatch AS ?relation)
        }
      }
  }

  UNION

  # BLOCK 2: THE RIGHT-SIDE ORPHANS
  {
      # 1. Start with ALL Potential Targets
      BIND("NAEBI" AS ?DB_T_Right)
      ?T a :CultivationType ;
         :partOf+ ct:14 ;
         :hasMembership [ schema:name ?DB_T_Right ] .

      # 2. Subtract the "Used" Targets using a Sub-Query
      MINUS {
          SELECT DISTINCT ?T 
          WHERE {
             BIND("AGIS" AS ?DB_S_Inner)
             BIND("NAEBI" AS ?DB_T_Inner)
             
             ?S_Inner a :CultivationType ;
                      :partOf+ ct:14 ;
                      :hasMembership [ schema:name ?DB_S_Inner ] .

             {
                # Match Logic A: Exact
                ?S_Inner :hasMembership [ schema:name ?DB_T_Inner ] .
                BIND(?S_Inner AS ?T)
             }
             UNION
             {
                # Match Logic B: Broad
                ?S_Inner :partOf+ ?T .
                ?T :hasMembership [ schema:name ?DB_T_Inner ] .
             }
             UNION
             {
                # Match Logic C: Narrow
                ?T :partOf+ ?S_Inner .
                ?T :hasMembership [ schema:name ?DB_T_Inner ] .
             }
          }
      }
  }
}
ORDER BY ?relation ?S ?T